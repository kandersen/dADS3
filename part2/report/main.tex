\documentclass[oneside,11pt,openright]{report}

\usepackage[latin1]{inputenc}
\usepackage[american]{babel}
\usepackage{a4}
\usepackage{latexsym}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{epsfig}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage[labeled]{multibib}
\usepackage{color}
\usepackage{datetime}
\usepackage{epstopdf} 
\usepackage{graphicx}
\usepackage{pgfplots}
\usepackage[format=hang]{caption}

\usepackage{pgf,tikz}
\usepackage{comment}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{backgrounds,fit}
\usetikzlibrary{shapes,patterns}
\usetikzlibrary{calc,chains,positioning}

\renewcommand*\ttdefault{txtt}
\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\left(#1\right)}}
\newcommand{\BigT}[1]{\ensuremath{\Theta\left(#1\right)}}
\newcommand{\specialcell}[2][c]{%
  \begin{tabular}[#1]{@{}c@{}}#2\end{tabular}}
% see http://imf.au.dk/system/latex/bog/

\newcommand{\adjustimg}{% Horizontal adjustment of image
  \ifodd\value{page}\hspace*{\dimexpr\evensidemargin-\oddsidemargin}\else\hspace*{-\dimexpr\evensidemargin-\oddsidemargin}\fi%
}
\newcommand{\centerimg}[2][width=\textwidth]{% Center an image
  \makebox[\textwidth]{\adjustimg\includegraphics[#1]{#2}}%
}
\newcommand{\MakeHeap}{\textsc{MakeHeap}}
\newcommand{\FindMin}{\textsc{FindMin}}
\newcommand{\Insert}{\textsc{Insert}}
\newcommand{\DeleteMin}{\textsc{DeleteMin}}
\newcommand{\DecreaseKey}{\textsc{DecreaseKey}}
\newcommand{\Delete}{\textsc{Delete}}
\newcommand{\Meld}{\textsc{Meld}}
\newcommand{\Dijkstra}{\textsc{Dijkstra}}
\newcommand{\NULL}{\textbf{null}}

\newcommand{\Member}{\textsc{Member}}
\newcommand{\Minimum}{\textsc{Minimum}}
\newcommand{\Maximum}{\textsc{Maximum}}
\newcommand{\Predecessor}{\textsc{Predecessor}}
\newcommand{\Successor}{\textsc{Successor}}

\newcommand{\HIGH}{\textsf{high}}
\newcommand{\LOW}{\textsf{low}}
\newcommand{\INDEX}{\textsf{index}}
\newcommand{\HIGHER}{\sqrt[\uparrow]{u}}
\newcommand{\LOWER}{\sqrt[\downarrow]{u}}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagestyle{empty} 
\pagenumbering{roman} 
\vspace*{\fill}\noindent{\rule{\linewidth}{1mm}\\[4ex]
{\Huge\sf Binary Heaps, Fibonacci Heaps and\\[2ex]Dijkstras shortest path}\\[4ex]
{\huge\sf Kristoffer Just Andersen, 20051234\\[2ex]
\huge\sf Troels Leth Jensen, 20051234 \\[2ex]
\huge\sf Morten Krogh-Jespersen, 20022362}\\[2ex]
\noindent\rule{\linewidth}{1mm}\\[4ex]
\noindent{\Large\sf Project 1, Advanced Data Structures 2013, Computer Science\\[1ex] 
\monthname\ \the\year  \\[1ex] Advisor: Gerth St√∏lting Brodal\\[15ex]}\\[\fill]}
\epsfig{file=logo.eps}\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\tableofcontents
\pagenumbering{arabic}
\setcounter{secnumdepth}{2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Introduction}

needs content

\chapter{Bit-vector}

A bit-vector or a bit array is a structure that supports $\Insert$, $\Delete$ and $\Member$ in constant time~\cite[p. 532]{ITA09}. To support storing elements of universe size $u$ we must have an array of length $u$ bits. An entry will be one if the element that the bit represents is in the set and it will be zero if not.

For $\Insert$ we set the bit to 1 for the index representing the key value of $u$. $\Delete$ clears the corresponding bit. Checking if the set contains an element is just checking if the bit for the element is set to 1~\footnote{\begin{align*}
& \textsc{TEST\_BIT}(var,pos) = ((var)\quad \&=\quad(1<<(pos))) \\
& \textsc{SET\_BIT}(var,pos)  = ((var)\quad|=\quad(1<<(pos))) \\
& \textsc{CLEAR\_BIT}(var,pos)  = ((var)\quad\&=\quad\textsf{\textasciitilde}(1<<(pos)))
\end{align*}}.

The bit-vector performs badly for $\Minimum$, $\Maximum$, $\Predecessor$ and $\Successor$ because the entire array could be traversed.

\begin{center}
  \begin{tabular}{ l | c }
    Operation & Bit-Vector  \\ \hline
    \Member & $\BigT{1}$ \\ 
    \Minimum & $\BigT{u}$ \\ 
    \Maximum & $\BigT{u}$ \\ 
    \Predecessor & $\BigT{u}$ \\ 
    \Successor & $\BigT{u}$ \\ 
    \Insert & $\BigT{1}$ \\ 
    \Delete & $\BigT{1}$ \\
  \end{tabular}
\end{center}


\chapter{Van Emde Boas Tree}

A van Emde Boas tree is a recursive data structure that supports finding the predecessor and successor in \BigT{\log \log m} time where $m$ is the size of the universe, in other words, the amount of distinct keys with a total ordering that the tree support~\cite[p. 545]{ITA09}~\cite{VEB04}. Because van Emde Boas Trees allow universe sizes of any power of 2, we denote $\HIGHER = 2^{\lceil{(\log u)/2}\rceil}$ and $\LOWER = 2^{\lfloor{(\log u)/2}\rfloor}$. Each level of the van Emde Boas Tree has a universe $u$ and it contains $\HIGHER$ clusters/bottom van Emde Boas trees of universe size $\LOWER$ and one auxilary van Emde Boas Tree of size $\HIGHER$ we denote top. For each recursion the universe shrinks by $\sqrt{u}$.

For each tree we have two attributes that store the minimum and the maximum key. The minimum key cannot be found in any of the bottom trees, neither can the maximum unless it differs from the minimum, which happens if there are more than one element in the tree. The attributes helps reduce the number of recursive calls, because one can in constant time decide if a value lies within the range, without the need to recurse.

Van Emde Boas Trees utilizes that keys are represented as bits and if we view a key $x$ as a $\log u$-bit binary integer, we can divide the bits up in a most significant and a least significant part. The most significant part of the bit vector identifies the cluster $\lfloor{x/\sqrt{u}}\rfloor$ where $x$ will apear in position $x \mod \sqrt{u}$ in the beforementioned bottom tree. Let us denote $\HIGH(x) = \lfloor{x/\sqrt{u}}\rfloor$ and $\LOW(x) = x \mod \sqrt{u}$ then we get the identity $x = \HIGH(x) \sqrt{u} + \LOW(x)$.

Below is the time-complexities of each operation listed for the corresponding data structure and let $u$ denote the size of the universe and $n$ the number of keys stored in the structure:

\begin{center}
  \begin{tabular}{ l | c | c | c }
    Operation & Bit-Vector & Red-Black Tree & van Emde Boas Tree \\ \hline
    \Member & $\BigT{1}$ & $\BigT{\log n}$ & $\BigO{\log \log u}$ \\ 
    \Minimum & $\BigT{u}$ & $\BigT{\log n}$ & $\BigO{1}$\\ 
    \Maximum & $\BigT{u}$ & $\BigT{\log n}$ & $\BigO{1}$ \\ 
    \Predecessor & $\BigT{u}$ & $\BigT{\log n}$ & $\BigO{\log \log u}$  \\ 
    \Successor & $\BigT{u}$ & $\BigT{\log n}$ & $\BigO{\log \log u}$ \\ 
    \Insert & $\BigT{1}$ & $\BigT{\log n}$ & $\BigO{\log \log u}$ \\ 
    \Delete & $\BigT{1}$ & $\BigT{\log n}$ & $\BigO{\log \log u}$ \\
  \end{tabular}
\end{center}

\section{Finding minimum or maximum key}

This is a constant operation, since the van Emde Boas Tree directly stores the minimum and maximum element.

\section{Finding a member}

Finding out if a key is stored in a van Emde Boas Tree is simple. Either the key is the minimum or the maximum element or else recurse until we find the element. It is easy to figure out which tree to recurse on, since this is the $\HIGH(x)$-th tree, and we just have to search in the smaller tree for $\LOW(x)$.

So how long does the search take in worst-case? The data structure can be described by the following recurrence function: 
\begin{align*}
    T(u) \leq T(\HIGHER) + \BigO{1}
\end{align*}
If we let $m = \log u$ and realize that $\lceil{m/2}\rceil \leq 2m/3$ for $m \geq 2$, which is the leaf size of the van Emde Boas Tree, we get:

\begin{align*}
    T(u)  & \leq T(\HIGHER) + \BigO{1} \\
    \Downarrow \\
    T(2^m) & \leq T(2^{\lceil{m/2}\rceil}) + \BigO{1} \\
    \Downarrow \\
    T(2^m) & \leq T(2^{2m/3}) + \BigO{1} \\
    \Downarrow \\
    S(m) & \leq S(2m/3) + \BigO{1} \\
\end{align*}

By the master thorem~\cite[p. 93]{ITA09}, has the solution $S(m) = \BigO{\log m}$. Because $T(u) = T(2^m)$ we get $\BigO{\log m} = \BigO{\log \log u}$. Therefore the procedure takes $\BigO{\log \log u}$.

\section{Finding a successor or a predecessor}

As with finding a member, for the base case a successor or predecessor can be found in constant time. If not, we have to determine where to find the next element we are searching for. Finding successor and predecessor is completely analog thus we only describe finding the successor for an element $x$.

First, we check if the sucessor is in the bottom tree at index $\HIGH(x)$. This check ban be done in constant time since it is a matter of checking maximum for that tree. If maximum exist and it is higher than $\LOW(x)$, we know we have to search inside that particular tree. This will take $\BigO{\log\log u}$ time.

If maximum does not exist or it is less than $\LOW(x)$ we use the top tree to search for the successor to $\HIGH(x)$. If we can find such an element it will gives us an index to a bottom tree $b$. Hereafter it is a constant lookup to find $\Minimum(b)$. This case also runs in $\BigO{\log\log u}$ time since we have on search in top and a constant lookup. Therefore, the total running time of successor and predecessor is $\BigO{\log\log u}$.

\section{Insert}

Insert is pretty simple. One of the following can happen:

\begin{itemize}
\item The list is empty, which can be discovered in constant time by checking the minimum attribute. If that is the case, insert just set min and max.
\item If not in the base case, find out if the bottom of $\HIGH(x)$ is empty. If that is the case, we can just set min and max as above and update the top structure. If not, we just call insert on the bottom tree for $\LOW(x)$.
\end{itemize}

Always remember to set max or swap with min (because min was not in the tree, but now has to be since it would no longer be min). Either, the insert function recurses on the top tree of size $\HIGHER$ or on one of the bottom trees of size $\LOWER$ but not on both. Therefore, the running time is at most $\BigO{\log \log u}$.

\section{Delete}

If there is only one element or universe size is 2 is easy to perform delete in constant time. Otherwise, some more work has to be done. Consider what should be done if we try to delete the minimum element. Since min is not stored in the tree, we have to find the minimum element in the bottom trees and make sure we delete it so that it can be placed as the new min. Of course, it can happen that the the bottom tree becomes empty so the top structure has to be updated. It might also be that we remove max but updating max is a constant operation.

In the description above we actually could make two recursive calls; one to update the bottom tree and possibly one to update the top. But if we update the top then the bottom tree would only contain one element. But if that is the case the first recursive function takes constant time. Therefore delete runs in $\BigO{\log \log n}$.

\chapter{Conlusion}

needs contents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\addcontentsline{toc}{chapter}{Bibliography}
\bibliographystyle{plain} 
\bibliography{report}

\end{document}

